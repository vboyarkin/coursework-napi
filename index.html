<!DOCTYPE HTML>
<html lang="ru-RU">

<head>
  <meta charset="utf-8">
  <title>Компоненты сильной связности графа</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Cambria, sans-serif;
    }

    .stroke {
      stroke: #069961;
      stroke-width: 1;
      fill: none;
    }

    .hidden {
      display: none;
      stroke: #ececec;
    }

    .node {
      stroke: none;
    }

    .nodeContainer:hover .node {
      fill: #07c77d;
      r: 27;
    }

    #adjacencyMatrix {
      margin: 15px 0 8px;
    }

    ul {
      padding-left: 16px;
    }

    .label {
      font-style: normal;
      font-weight: bold;
      font-size: 28px;
      text-align: center;
      text-anchor: middle;
      user-select: none;
      fill: #ffffff
    }

    .node_colored {
      fill: #06b370;
      overflow: visible;
    }

    /* .selected {
            color: #e62c2c;
        }

        .highlighted {
            fill: #ff5555;
        } */

    .tableContainer {
      position: absolute;
      top: 16px;
      left: 18px;
    }

    .legend {
      width: 12px;
      display: inline-block;
      font-family: Cambria, sans-serif;
    }

    .horizontal {
      width: 20px;
    }

    .horizontal:first-of-type {
      margin-left: 17px;
    }

    input[type="button"],
    input[type="number"],
    button {
      padding: 3px;
      margin: 5px;
    }

    .verticesForm {
      /* width: 50px; */
      padding-left: 8px;
    }

    .verticesForm input {
      display: block;
    }
  </style>
</head>


<body>
  <div class="tableContainer">
    <form class="verticesForm" id="counter">
      <input id="nodesCounter" type="number" name="counter">
    </form>
    <form id="matrixWrapper">
      <div id="adjacencyMatrix"></div>
      <button id="buttonCalculate" type="Button" name="calculate" value="Calculate">Вычислить</button>
      <button id="buttonShake" type="Button" name="shake" value="Shake">Встряхнуть</button>
    </form>
    <div id="results"></div>
  </div>
  <div class="svgContainer">
    <svg id=graph width="100%" height="700">
      <defs>
        <marker id="marker_s" orient="auto" refY="0" refX="-36" class="node_colored">
          <path d="M 0,0 5,-5 -12.5,0 5,5 Z" />
        </marker>
        <marker id="marker_e" orient="auto" refY="0" refX="23.5" class="node_colored">
          <path d="m -12.5,0 -5,-5 L 0,0 -17.5,5 Z" />
        </marker>
      </defs>
      <g id="strokes"></g>
      <g id="nodes"></g>

    </svg>
  </div>
  <script>
    "use strict";

    function buildNode(number, x, y) {
      let svgns = "http://www.w3.org/2000/svg";
      let g = document.createElementNS(svgns, 'g');

      g.setAttribute('id', `node_${number}`);
      g.classList.add('nodeContainer')
      g.setAttribute('transform', `translate(${x},${y})`);
      g.innerHTML = `<circle class="node node_colored" r="24" cx="0" cy="0" />
                <text class="label" x="0" y="10" >${number + 1}</text>`;

      return g;
    }

    function buildStroke(from, to, direction) {
      let svgns = "http://www.w3.org/2000/svg";
      let path = document.createElementNS(svgns, 'path');

      path.setAttribute('d', `m ${from.position.x},${from.position.y} ${to.position.x - from.position.x},${to.position.y - from.position.y}`);
      return path;
    }

    function buildCheckbox(i, j) {
      let label = document.createElement('label');
      let checkbox = document.createElement('input');

      checkbox.setAttribute('type', 'checkbox');
      checkbox.setAttribute('id', `${i}_${j}`);
      checkbox.setAttribute('name', `${i}_${j}`);
      checkbox.onclick = checkboxChange;

      label.appendChild(checkbox);

      return label
    }

    function reverse() {
      for (let e of edges) {
        if (Math.abs(e.direction) == 1) {
          e.direction *= -1;
        }
      }
    }

    function buildResults() {
      results.innerHTML = '';
      let resultsList = document.createElement('ul');
      results.appendChild(resultsList);
      resultsList.insertAdjacentHTML('beforebegin', `<p>Число внешней устойчивости<br> равно ${dnf[0].length}.</p><p>Минимальные внешне<br> устойчивые подмножества:</p>`);
      for (let i = 0; i < dnf.length; i++) {
        let li = document.createElement('li');
        for (let j in dnf[i]) {
          if (j < dnf[i].length - 1) {
            li.insertAdjacentText('beforeend', `${String.fromCharCode(97 + dnf[i][j])}, `);
          } else {
            li.insertAdjacentText('beforeend', `${String.fromCharCode(97 + dnf[i][j])}`);
          }
        }
        li.setAttribute('id', `li_${i}`);
        li.onclick = highlightNodes;
        resultsList.appendChild(li);
      }
    }

    function checkboxChange() {
      results.innerHTML = '';

      let [v1, v2] = this.id.split("_");
      v1 = parseInt(v1);
      v2 = parseInt(v2);

      if (v1 == v2) return;

      let edge;

      if (v1 < v2) {
        edge = edges[nodesSize * v1 + v2 - calculateIndexSurplus(v1)];
      } else {
        edge = edges[nodesSize * v2 + v1 - calculateIndexSurplus(v2)];
      }

      if (this.checked) {
        if (edge.direction == 0) {
          if (v1 < v2) {
            edge.direction = 1;
          } else if ((v1 > v2)) {
            edge.direction = -1;
          }
          edge.stroke.classList.remove("hidden");
          edge.updateConnections();
        } else {
          edge.direction = 2;
          edge.updateConnections();
        }
      } else {
        if (edge.direction == 2) {
          if (v1 < v2) {
            edge.direction = -1;
          } else if ((v1 > v2)) {
            edge.direction = 1;
          }
          edge.updateConnections();
        } else {
          edge.direction = 0;
          edge.stroke.classList.add('hidden');
        }
      }
      recalculateCnf();
    }

    function node(element) {
      this.node = element;
      this.position = { x: 550 + Math.random() * 15, y: 250 + Math.random() * 5 };
      this.velocity = { x: 0, y: 0 };
      this.acceleration = { x: 0, y: 0 };

      this.addForce = function (x, y) {
        this.acceleration.x += x;
        this.acceleration.y += y;
      };

      this.updatePosition = function () {
        this.velocity.x += this.acceleration.x;
        this.velocity.y += this.acceleration.y;
        this.velocity.x *= DRAG;
        this.velocity.y *= DRAG;

        if (Math.abs(this.velocity.x) < ZERO_VELOCITY) this.velocity.x = 0;
        if (Math.abs(this.velocity.y) < ZERO_VELOCITY) this.velocity.y = 0;

        this.position.x += this.velocity.x;
        this.position.y += this.velocity.y;
        this.acceleration.x = 0;
        this.acceleration.y = 0;

        this.node.setAttribute('transform', `translate(${this.position.x},${this.position.y})`);
      };
    }

    function edge(from, to, direction) {
      this.from = from;
      this.to = to;
      this.direction = direction;
      this.stroke = buildStroke(from, to, direction);
      this.updatePosition = function () {
        this.stroke.setAttribute('d', `m ${from.position.x},${from.position.y} ${to.position.x - from.position.x},${to.position.y - from.position.y}`);
      }
      this.updateConnections = function () {
        this.stroke.setAttribute('class', 'stroke');
        if (this.direction === 2) {
          this.stroke.setAttribute('style', "marker-start:url(#marker_s);marker-end:url(#marker_e)");
        } else if (this.direction === 1) {
          this.stroke.setAttribute('style', "marker-end:url(#marker_e)");
        } else if (this.direction === -1) {
          this.stroke.setAttribute('style', "marker-start:url(#marker_s)");
        } else { // direction === 0
          this.stroke.setAttribute('class', 'stroke hidden');
        }
      }
    }

    function calculateIndexSurplus(i) {
      let surplus = 0;
      for (i += 1; i > 0; i--) {
        surplus += i;
      }
      return surplus;
    }

    function calculateForces() {
      const c1 = 2.01;
      const c2 = 170.01;
      const c3 = 1.51;
      const c4 = 300.05;
      let distance;
      let distanceX;
      let distanceY;
      let force;
      let forceX;
      let forceY;

      for (let stroke of edges) {
        if (stroke.direction) {
          distanceX = stroke.from.position.x - stroke.to.position.x;
          distanceY = stroke.from.position.y - stroke.to.position.y;
          distance = Math.sqrt((distanceX) ** 2 + (distanceY) ** 2) + Math.random() / 5;
          force = c1 * Math.log(Math.abs(distance) / c2);
          forceX = force * distanceX / distance;
          forceY = force * distanceY / distance;
          stroke.from.acceleration.x -= forceX;
          stroke.from.acceleration.y -= forceY;
          stroke.to.acceleration.x += forceX;
          stroke.to.acceleration.y += forceY;
        } else {
          distanceX = stroke.from.position.x - stroke.to.position.x;
          distanceY = stroke.from.position.y - stroke.to.position.y;
          distance = Math.sqrt((distanceX) ** 2 + (distanceY) ** 2) + Math.random() / 5;
          force = c3 * Math.log(Math.abs(distance) / c4);
          forceX = force * distanceX / distance;
          forceY = force * distanceY / distance;
          stroke.from.acceleration.x -= forceX;
          stroke.from.acceleration.y -= forceY;
          stroke.to.acceleration.x += forceX;
          stroke.to.acceleration.y += forceY;
        }
      }
    }
    function onlyUnique(value, index, self) {
      return self.indexOf(value) === index;
    }
    function cnf2dnf(elements) {
      if (!Array.isArray(elements)) throw new TypeError();

      let end = elements.length - 1,
        result = [];

      function addTo(curr, start) {
        let first = elements[start],
          last = (start === end);

        for (let i = 0; i < first.length; ++i) {
          let copy = curr.slice();
          copy.push(first[i]);

          if (last) {
            result.push(copy.filter(onlyUnique).sort());
          } else {
            addTo(copy, start + 1);
          }
        }
      }

      if (elements.length) {
        addTo([], 0);
      } else {
        result.push([]);
      }

      return result;
    }

    function isRedundand(sample, suspect) {
      for (let i = 0; i < sample.length; i++) {
        let offset = 0;
        while (sample[i] > suspect[i + offset]) {
          offset++;
        }
        if (sample[i] != suspect[i + offset]) return 0;
      }
      return 1;
    }

    function reduce(array) {
      let i = 0;
      let sample;
      while (sample = array[i]) {
        for (let j = array.length - 1; j > i; j--) {
          if (isRedundand(sample, array[j])) {
            array.splice(j, 1);
          }
        }
        i++;
      }
    }

    function shake() {
      event.preventDefault();
      for (let n of nodes) {
        n.velocity.x = Math.random() * 50 - 25;
        n.velocity.y = Math.random() * 50 - 25;
      }
    }

    function findStability() {
      event.preventDefault();

      const mx = tableToMx();



      const result = hello_world.compute_str();


      buildResults();
    }


    function animate() {
      calculateForces();
      for (let i = 0; i < nodesSize; i++) {
        nodes[i].addForce(nodes[i].acceleration.x, nodes[i].acceleration.y);
        nodes[i].updatePosition();
      }
      for (let stroke of edges) {
        stroke.updatePosition();
      }
    }

    function tableToMx() {
      const mx = [];

      for (let i = 0; i < nodes.length; i++) {
        const row = [];

        for (let j = 0; j < nodes.length; j++) {
          const checkbox = document.getElementById(`${i}_${j}`);
          row[j] = checkbox.checked ? 1 : 0;
        }

        mx[i] = row;
      }

      return mx;
    }

    // ---------------------------------------------------------------------------------------

    const DRAG = 0.7
    const ZERO_VELOCITY = 0.03
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    let counterValue = urlParams.get('counter');
    counterValue ||= 7;
    let counter = document.getElementById('nodesCounter');
    counter.value = counterValue;

    let nodesSize = parseInt(counter.value);
    let nodes = [];
    let edges = [];
    let dnf = [];
    let cnf = [];
    let canvas = document.getElementById('nodes');
    let strokes = document.getElementById('strokes');
    let counterForm = document.getElementById('counter');
    let matrixForm = document.getElementById('adjacencyMatrix');
    let svg = document.getElementById('graph');
    let results = document.getElementById('results');

    document.getElementById('buttonCalculate').onclick = findStability;
    document.getElementById('buttonShake').onclick = shake;


    for (let i = 0; i < nodesSize; i++) {
      matrixForm.insertAdjacentHTML('beforeend', `<span class="legend horizontal">${i} </span>`);
    }

    for (let i = 0; i < nodesSize; i++) {
      let div = document.createElement('div');
      div.insertAdjacentHTML('afterbegin', `<span class="legend">${i} </span>`);

      for (let j = 0; j < nodesSize; j++) {
        div.appendChild(buildCheckbox(i, j));
      }

      matrixForm.appendChild(div);
    }

    for (let i = 0; i < nodesSize; i++) {
      let nodeImg = buildNode(i, i * 100, i * 50);
      canvas.appendChild(nodeImg);
      nodes.push(new node(nodeImg));
    }

    let matrixRows = matrixForm.getElementsByTagName('div');
    for (let i = 0; i < nodesSize; i++) {
      let matrixRowElements = matrixRows[i].getElementsByTagName('input');

      for (let j = 0; j < nodesSize; j++) {
        if (i < j) {
          if (matrixRowElements[j].checked) {
            edges.push(new edge(nodes[i], nodes[j], 1));
          } else {
            edges.push(new edge(nodes[i], nodes[j], 0));
          }
        } else {
          if (matrixRowElements[j].checked) {
            if (matrixRows[j].getElementsByTagName('input')[i].checked) {
              edges[nodesSize * j + i - calculateIndexSurplus(j)].direction = 2;
            } else {
              edges[nodesSize * j + i - calculateIndexSurplus(j)].direction = -1;
            }
          }
        }
      }
    }

    for (let stroke of edges) {
      strokes.appendChild(stroke.stroke);
      stroke.updateConnections();
    }

    let delay = setInterval(animate, 35);

  </script>
</body>

</html>