<!DOCTYPE HTML>
<html lang="ru-RU">

<head>
  <meta charset="utf-8">
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">
  <title>Компоненты сильной связности графа</title>
  <link rel="stylesheet" href="./index.css">
</head>

<body>
  <div class="tableContainer">
    <form class="verticesForm" id="counter">
      <label>Количество вершин в графе</label>
      <input id="nodesCounter" type="number" name="counter">
    </form>
    <form id="matrixWrapper">
      <div id="adjacencyMatrix"></div>
      <button class="button green" id="buttonCalculate" type="Button" name="calculate"
        value="Calculate">Вычислить</button>
      <button class="button green" id="buttonShake" type="Button" name="shake" value="Shake">Встряхнуть</button>
    </form>
    <div id="results"></div>
  </div>
  <div class="svgContainer">
    <svg id=graph width="100%" height="700">
      <defs>
        <marker id="marker_s" orient="auto" refY="0" refX="-36" class="node_colored">
          <path class="marker_bg" d="M 0,0 0,-5 -12.5,0 0,5 Z"></path>
          <path d="M 0,0 0,-5 -12.5,0 0,5 Z"></path>
        </marker>
        <marker id="marker_e" orient="auto" refY="0" refX="23.5" class="node_colored">
          <path class="marker_bg" d="m -12.5,0 -0,-5 L 0,0 -12.5,5 Z"></path>
          <path d="m -12.5,0 -0,-5 L 0,0 -12.5,5 Z"></path>
        </marker>
      </defs>
      <g id="strokes"></g>
      <g id="nodes"></g>

    </svg>
  </div>
  <script>
    "use strict";

    function buildNode(number, x, y) {
      let svgns = "http://www.w3.org/2000/svg";
      let g = document.createElementNS(svgns, 'g');

      g.setAttribute('id', `node_${number}`);
      g.classList.add('nodeContainer')
      g.setAttribute('transform', `translate(${x},${y})`);
      g.innerHTML = `
        <circle class="node_bg" r="24" cx="0" cy="0"/>
        <circle class="node node_colored" r="24" cx="0" cy="0"/>
        <circle class="node_colored" r="24" cx="0" cy="0"/>
        <text class="label" x="0" y="10">${number + 1}</text>`;

      return g;
    }

    function buildStroke(from, to, direction) {
      let svgns = "http://www.w3.org/2000/svg";
      let path = document.createElementNS(svgns, 'path');

      path.setAttribute('d', `m ${from.position.x},${from.position.y} ${to.position.x - from.position.x},${to.position.y - from.position.y}`);
      return path;
    }

    function buildCheckbox(i, j) {
      let label = document.createElement('label');
      let checkbox = document.createElement('input');

      checkbox.setAttribute('type', 'checkbox');
      checkbox.setAttribute('id', `${i}_${j}`);
      checkbox.setAttribute('name', `${i}_${j}`);
      checkbox.onclick = checkboxChange;

      label.appendChild(checkbox);

      return label
    }

    function showResults(result_str) {
      results.innerHTML = '';

      const components = result_str.scc
        .split('\n')
        .map(str => str.trim())
        .filter(x => x);

      const components_html = components
        .map(
          comp => comp.split(' ')
            .map(vert => `<span class="scc_vertice">${vert}</span>`)
            .join(' ')
        )
        .map(comp => `<div class"scc_container"><p class="scc">${comp}</p></div>`)
        .join('\n');

      const head = `<label>Число компонент<br>сильной связности: ${components.length}</label>\n`;

      results.innerHTML = head + components_html;
    }

    function checkboxChange() {
      results.innerHTML = '';

      let [v1, v2] = this.id.split("_");
      v1 = parseInt(v1);
      v2 = parseInt(v2);

      if (v1 == v2) return;

      let edge;

      if (v1 < v2) {
        // edge = edges[nodesSize * v1 + v2 - getUnusedEdgesOffset(v1)];
        edge = getEdge(v2, v1)
      } else {
        // edge = edges[nodesSize * v2 + v1 - getUnusedEdgesOffset(v2)];
        edge = getEdge(v1, v2)
      }

      if (this.checked) {
        if (edge.direction == 0) {
          if (v1 < v2) {
            edge.direction = 1;
          } else if ((v1 > v2)) {
            edge.direction = -1;
          }
          edge.stroke.classList.remove("hidden");
          edge.updateConnections();
        } else {
          edge.direction = 2;
          edge.updateConnections();
        }
      } else {
        if (edge.direction == 2) {
          if (v1 < v2) {
            edge.direction = -1;
          } else if ((v1 > v2)) {
            edge.direction = 1;
          }
          edge.updateConnections();
        } else {
          edge.direction = 0;
          edge.stroke.classList.add('hidden');
        }
      }
    }

    function node(element) {
      this.node = element;
      this.position = { x: 550 + Math.random() * 15, y: 250 + Math.random() * 5 };
      this.velocity = { x: 0, y: 0 };
      this.acceleration = { x: 0, y: 0 };

      this.addForce = function (x, y) {
        this.acceleration.x += x;
        this.acceleration.y += y;
      };

      this.updatePosition = function () {
        this.velocity.x += this.acceleration.x;
        this.velocity.y += this.acceleration.y;
        this.velocity.x *= C_SLOW;
        this.velocity.y *= C_SLOW;

        if (Math.abs(this.velocity.x) < ZERO_VELOCITY) this.velocity.x = 0;
        if (Math.abs(this.velocity.y) < ZERO_VELOCITY) this.velocity.y = 0;

        this.position.x += this.velocity.x;
        this.position.y += this.velocity.y;
        this.acceleration.x = 0;
        this.acceleration.y = 0;

        this.node.setAttribute('transform', `translate(${this.position.x},${this.position.y})`);
      };
    }

    function edge(from, to, direction) {
      this.from = from;
      this.to = to;
      this.direction = direction;
      this.stroke = buildStroke(from, to, direction);

      this.updatePosition = function () {
        this.stroke.setAttribute('d', `m ${from.position.x},${from.position.y} ${to.position.x - from.position.x},${to.position.y - from.position.y}`);
      }
      this.updateConnections = function () {
        this.stroke.setAttribute('class', 'stroke');
        if (this.direction === 2) {
          this.stroke.setAttribute('style', "marker-start:url(#marker_s);marker-end:url(#marker_e)");
        } else if (this.direction === 1) {
          this.stroke.setAttribute('style', "marker-end:url(#marker_e)");
        } else if (this.direction === -1) {
          this.stroke.setAttribute('style', "marker-start:url(#marker_s)");
        } else { // direction === 0
          this.stroke.setAttribute('class', 'stroke hidden');
        }
      }
    }

    function getUnusedEdgesOffset(i) {
      return (i + 2) * (i + 1) / 2;
    }

    function getEdge(i, j) {
      return edges[nodesSize * j + i - getUnusedEdgesOffset(j)];
    }

    function calculateForces() {
      const c1 = 2.01;
      const c2 = 170.01;
      const c3 = 1.51;
      const c4 = 300.05;

      for (let stroke of edges) {
        const distanceX = stroke.from.position.x - stroke.to.position.x;
        const distanceY = stroke.from.position.y - stroke.to.position.y;
        const distance = Math.sqrt((distanceX) ** 2 + (distanceY) ** 2) + Math.random() / 5;

        const Cl = stroke.direction ? c1 : c3;
        const Cr = stroke.direction ? c2 : c4;

        const force = Cl * Math.log(Math.abs(distance) / Cr);

        const forceX = force * distanceX / distance;
        const forceY = force * distanceY / distance;

        stroke.from.acceleration.x -= forceX;
        stroke.from.acceleration.y -= forceY;
        stroke.to.acceleration.x += forceX;
        stroke.to.acceleration.y += forceY;
      }
    }

    function shake() {
      event.preventDefault();
      for (const n of nodes) {
        n.velocity.x = Math.random() * 50 - 25;
        n.velocity.y = Math.random() * 50 - 25;
      }
    }

    function animate() {
      calculateForces();

      for (let i = 0; i < nodesSize; i++) {
        nodes[i].addForce(nodes[i].acceleration.x, nodes[i].acceleration.y);
        nodes[i].updatePosition();
      }
      for (let stroke of edges) {
        stroke.updatePosition();
      }
    }

    function findScc() {
      event.preventDefault();

      const mx = tableToMx();
      const mx_str = mx
        .map(row => row.join(' '))
        .join('\n');

      const result = compute_str(mx.length + "\n" + mx_str);

      showResults(result);
    }

    function tableToMx() {
      const mx = [];

      for (let i = 0; i < nodes.length; i++) {
        const row = [];

        for (let j = 0; j < nodes.length; j++) {
          const checkbox = document.getElementById(`${i}_${j}`);
          row[j] = checkbox.checked ? 1 : 0;
        }

        mx[i] = row;
      }

      return mx;
    }

    ////////////////////////////////////////////////////

    const C_SLOW = 0.7
    const ZERO_VELOCITY = 0.04
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    let counterValue = urlParams.get('counter');
    counterValue = counterValue || 5;
    let counter = document.getElementById('nodesCounter');
    counter.value = counterValue;

    let nodes = [];
    let edges = [];
    let canvas = document.getElementById('nodes');
    let strokes = document.getElementById('strokes');
    let counterForm = document.getElementById('counter');
    let matrixForm = document.getElementById('adjacencyMatrix');
    let svg = document.getElementById('graph');
    let results = document.getElementById('results');

    document.getElementById('buttonCalculate').onclick = findScc;
    document.getElementById('buttonShake').onclick = shake;


    let nodesSize = parseInt(counter.value);
    for (let i = 0; i < nodesSize; i++) {
      matrixForm.insertAdjacentHTML('beforeend', `<span class="legend horizontal">${i + 1} </span>`);
    }

    for (let i = 0; i < nodesSize; i++) {
      let div = document.createElement('div');
      div.insertAdjacentHTML('afterbegin', `<span class="legend">${i + 1} </span>`);

      for (let j = 0; j < nodesSize; j++) {
        div.appendChild(buildCheckbox(i, j));
      }

      matrixForm.appendChild(div);
    }

    for (let i = 0; i < nodesSize; i++) {
      let nodeImg = buildNode(i, i * 100, i * 50);
      canvas.appendChild(nodeImg);
      nodes.push(new node(nodeImg));
    }

    let matrixRows = matrixForm.getElementsByTagName('div');
    for (let i = 0; i < nodesSize; i++) {
      let matrixRowElements = matrixRows[i].getElementsByTagName('input');

      for (let j = 0; j < nodesSize; j++) {
        if (i < j) {
          if (matrixRowElements[j].checked) {
            edges.push(new edge(nodes[i], nodes[j], 1));
          } else {
            edges.push(new edge(nodes[i], nodes[j], 0));
          }
        } else {
          if (matrixRowElements[j].checked) {
            if (matrixRows[j].getElementsByTagName('input')[i].checked) {
              // edges[nodesSize * j + i - getUnusedEdgesOffset(j)].direction = 2;
              getEdge(i, j).direction = 2;
            } else {
              // edges[nodesSize * j + i - getUnusedEdgesOffset(j)].direction = -1;
              getEdge(i, j).direction = -1;
            }
          }
        }
      }
    }

    for (let stroke of edges) {
      strokes.appendChild(stroke.stroke);
      stroke.updateConnections();
    }

    let delay = setInterval(animate, 35);

  </script>
</body>

</html>